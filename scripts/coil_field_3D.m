function out = coil_field_3D(shape, axs, x, y, z, I, R, N, varargin)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% DESCRIPTION: COIL_FIELD_3D calculates the magnetic field generated by a coil 
% oriented along the z axis, in a point of the space with coordinates (x, y, z)
% referred to the coil's center.
% Note 1. Calculation is based on elliptic integrals.
% Note 2: It assumes that the coil windings are colocated. To account for
% the finite size of the coils, use multiple_coils.m
% Note 3: x, y, z can be vectors!
%
%
% CALL:       B = coil_field_3D(shape, axs, x, y, z, I, R, N, varargin)
%
%
% INPUTS:
%   shape - shape of the coil: 'round', 'square' or 'rect'
%   axs   - component of the B vector to calculate ('x', 'y', 'z')
%   x     -	distance(s) from the source axis to calculate the field at, in m
%   y     -	distance(s) from the source axis to calculate the field at, in m
%   z     - distance(s) from the source plane to calculate the field at, in m
%   I     - current flowing through the coil, in A
%   R     - for round coils: radius;
%           for square coils: side length;
%           for rectangular coils: vector with the side lengths
%   N     - number of turns
%
%
% OUTPUTS:
%       B - the magnetic field, in T, will be Bi = Bi(x, y, z)
%           with i = x, y or z
%
%
% PARAMETERS:
% 'tol_factor'   increases machine tolerance by a factor specified by next
%                arg (default:100)
% 'biot'         uses Biot-Savart law instead, next arg is number of points
%
%
% VERSION:     $Id: coil_field_3D.m 4253 2013-09-10 07:03:26Z mauro.hueller $
%
%
% HISTORY:     04-04-2003 M Hueller
%                 Creation
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

VERSION = '$Id: coil_field_3D.m 4253 2013-09-10 07:03:26Z mauro.hueller $';

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

tol_factor = 100;
mu0 = 4*pi*1.e-7;
calc_method = 'ellip';
npoints = 100;
talk = true;

% coil's area
if strcmp (shape,'round') == 1
  A = pi*R^2;
elseif strcmp (shape,'rect') == 1
  A = R(1)*R(2);
else
  A = R^2;
end

m0 = N*I*A;                     % coil's magnetic moment

if ~isempty(varargin)
  jj = 1;
  while jj <= length(varargin)
    switch lower(varargin{jj})
      case 'talk'
        talk = varargin{jj+1};
        jj = jj + 1;
      case 'tol'
        tol_factor = varargin{jj+1};
        jj = jj + 2;
      case 'biot'
        calc_method = 'biot';
        npoints = varargin{jj+1};
        jj = jj + 2;
      otherwise
        disp(['Unknown option "' num2str(varargin{jj}) '"'])
    end
    jj = jj + 1;
  end
end

if talk 
  disp([' Magnetic moment = ' num2str(m0) ' Am^2']);
end

Rho_min = 1.e-15;				% to avoid working at zero
tolerance = eps*tol_factor;		% tolerance for integrals evaluation


% Rotating the input arrays to work only with columns:

if size(x,2) > 1
  x = x';
end
if size(y,2) > 1
  y = y';
end
if size(z,2) > 1
  z = z';
end


% Building the 3 dimensional space points matrix

[X,Y,Z] = meshgrid(x,y,z);


% Choice between round and square source coil

if strcmp(shape,'round') == 1
  % Round coil

  % Choice between calculation method
  if strcmp(calc_method, 'ellip') == 1

    % Ellyptic function evaluation

    [Phi,Rho,Z] = cart2pol(X,Y,Z);            			% cylindrical coordinates
    def_Rho = (Rho>0);
    def_Phi = (abs(Phi) < pi);

    Rho = Rho.*def_Rho + Rho_min*(~def_Rho);		% to avoid divergence at rho = 0

    ksq = (4*R*Rho)./((R+Rho).^2+Z.^2);				% k parameter for complete ellyptic integrals


    % Let's now calculate the field in the points (rho,phi=0,z).
    % The formulas come from E. Durand, 'Magnetostatique', pp. 35-36, and are obtained by
    % complete ellyptical functions evaluation.

    [J1,J2] = ellipke(ksq,tolerance);

    B_z = 2*N*I*mu0/(4*pi)./sqrt((R+Rho).^2+Z.^2).*(J1+J2.*(R^2-Rho.^2-Z.^2)./((R-Rho).^2+Z.^2));
    B_Rho = 2*N*I*mu0/(4*pi)./sqrt((R+Rho).^2+Z.^2).*Z./Rho.*(-J1+J2.*(R^2+Rho.^2+Z.^2)./((R-Rho).^2+Z.^2));
    B_Rho(~def_Rho) = 0; % when rho = 0, we are along axis, where B = (0,0,Bz)

    Phi_sin = Phi.*def_Phi + 0*(~def_Phi);			% to avoid working at phi = pi


    % Now back to the cartesian coordinates

    B_X = B_Rho.*cos(Phi);
    B_Y = B_Rho.*sin(Phi_sin);
    B_Z = B_z;
  else
    % Fields from Biot-Savart law
    B_X = zeros(size(X));
    B_Y = zeros(size(X));
    B_Z = zeros(size(X));

    for jj = 0 : (npoints - 1)
      eta = (2*pi)/npoints * jj;

      x_e = R * cos(eta);
      y_e = R * sin(eta);
      z_e = 0;

      r3 = ((X - x_e).^2 + (Y - y_e).^2 + (Z - z_e).^2).^(3/2);

      dL_x = -(2*pi)* R / npoints * sin(eta);
      dL_y = (2*pi)* R / npoints * cos(eta);
      dL_z = 0;


      % Contribution from one current element
      F = (N * I * mu0 ./ ((4*pi) * r3));
      B_X = B_X + F .* (dL_y .* (Z - z_e) - dL_z .* (Y - y_e));
      B_Y = B_Y + F .* (dL_z .* (X - x_e) - dL_x .* (Z - z_e));
      B_Z = B_Z + F .* (dL_x .* (Y - y_e) - dL_y .* (X - x_e));

    end

  end

else
  % Rectangular coil
  % Let's calculate that as the sum of 4 rectilinear segments
  % Formula from M. Misakian, J. Res. Natl. Inst. Stand. Technol. 105,
  % 557 (2000), pag. 558

  % disp ('Using Misakian formula');

  % Coil corners locations:

  if strcmp (shape,'square') == 1
    Lx = R;
    Ly = R;
  else
    Lx = R(1);
    Ly = R(2);
  end

  % Parameters (see Fig. 1 in the paper)

  a = Ly/2;
  b = Lx/2;

  n1 = (size(X,1));
  n2 = (size(X,2));
  n3 = (size(X,3));

  C = zeros(n1,n2,n3,4);
  d = zeros(n1,n2,n3,4);
  r = zeros(n1,n2,n3,4);

  C(:,:,:,1) = a + X;
  C(:,:,:,2) = a - X;
  C(:,:,:,3) = -C(:,:,:,2);
  C(:,:,:,4) = -C(:,:,:,1);

  d(:,:,:,1) = Y + b;
  d(:,:,:,2) = d(:,:,:,1);
  d(:,:,:,3) = Y - b;
  d(:,:,:,4) = d(:,:,:,3);

  r(:,:,:,1) = sqrt((a + X).^2 + (Y + b).^2 + Z.^2);
  r(:,:,:,2) = sqrt((a - X).^2 + (Y + b).^2 + Z.^2);
  r(:,:,:,3) = sqrt((a - X).^2 + (Y - b).^2 + Z.^2);
  r(:,:,:,4) = sqrt((a + X).^2 + (Y - b).^2 + Z.^2);

  B_Z = zeros(size(X));
  B_X = zeros(size(X));
  B_Y = zeros(size(X));

  for ii = 1 : 4
    B_Z = B_Z + ...
      N*I*mu0/(4*pi) * ((((-1)^ii)*d(:,:,:,ii)./((r(:,:,:,ii).*(r(:,:,:,ii)+((-1)^(ii+1)).*C(:,:,:,ii))))-(C(:,:,:,ii)./(r(:,:,:,ii).*(r(:,:,:,ii)+d(:,:,:,ii))))));
    B_X = B_X + ...
      N*I*mu0/(4*pi) * ((Z.*((-1)^(ii+1)))./(r(:,:,:,ii).*(r(:,:,:,ii)+d(:,:,:,ii))));
    B_Y = B_Y + ...
      N*I*mu0/(4*pi) * ((Z.*(-1)^(ii+1))./(r(:,:,:,ii).*(r(:,:,:,ii)+C(:,:,:,ii).*(-1)^(ii+1))));
  end

end

% Choosing the output component

if strcmp(axs,'x')
  out = B_X;
elseif strcmp(axs,'y')
  out = B_Y;
else
  out = B_Z;
end


